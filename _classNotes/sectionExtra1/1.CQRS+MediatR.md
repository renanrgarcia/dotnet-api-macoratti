# CQRS and MediatR

- **CQRS** stands for Command Query Responsibility Segregation. It's a pattern that separates the read and write operations of a data store. It's a pattern that can be used in conjunction with **MediatR** to create a more maintainable and testable codebase.
- **Command**: Represents a write operation. It's used to perform actions that change the state.
  - Task-based, not data-based. Can be processed asynchronously on a queue.
- **Query**: Represents a read operation. It's used to retrieve data from the data store.
  - Never changes the database state. Returns a DTO that doesn't encapsulate any domain logic.
- We can have synchronization between the read and write operations, but it's not mandatory.
- We can have separate databases optimized for read and write operations.

## Pros and Cons

- **Pros**:
  - **Separation of Concerns**: It's easier to maintain and test the code.
  - **Scalability**: We can scale the read and write operations independently.
  - **Performance**: We can optimize the read and write operations.
- **Cons**:
  - **Complexity**: It can add complexity to the codebase.
  - **Eventual Consistency**: We can have synchronization issues between the read and write operations.
- When not to use:
  - **Simple CRUD operations**: It's overkill for simple operations.
  - **Small projects**: It can add unnecessary complexity. - KISS principle.

## MediatR

- **Mediator**: behavioral design pattern that allows loose coupling between objects.
- **MediatR**: library that implements the mediator pattern in C#.
- With CQRS, we can use MediatR to send commands and queries to the handlers.

## UnitOfWork

- **Unit of Work**: It's a design pattern that ensures that all the operations are performed as a single transaction.
  - It ensures that all the operations are performed successfully or none of them. Focus on consistency.
